# Домашнее задание к занятию «Работа в терминале. Лекция 2»

Ответьте на вопросы:

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей и поясните, если считаете, что она могла бы быть другого типа.

***Ответ:***
	`cd` это встроеная команда bash. Она имеет такой тип, потому что меняет текущую директорию только в оболочке, и не производит никаких действий с файлами. 

2. Какая альтернатива без pipe для команды `grep <some_string> <some_file> | wc -l`?  

***Ответ:***
	Для решения этой задачи у команды `grep` есть флаг `-C`
	`grep -C <some_string> <some_file>`

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

***Ответ:***
	systemd

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

***Ответ:***
	`ls 2> /dev/pts1`
	Чтобы узнать файл сессии терминала на который необходимо отправить вывод, можно воспользоваться командой `tty`
	`2>` означает, что выводить данные необходимо только с дескриптора ошибок.

5. Получится ли одновременно передать команде файл на stdin и вывести её stdout в другой файл? Приведите работающий пример.

***Ответ:***
	`wc<file>result`	

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

***Ответ:***
	Да. Например командой `echo Hello > /dev/tty3` 	

7. Выполните команду `bash 5>&1`. К чему она приведёт? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

***Ответ:***
	`bash 5>&1` создает промежуточный дескриптор 5 у процесса bash.
	`echo netology > /proc/$$/fd/5` выведет на экран "netology". Это происходит потому, что мы отправляем результат команды `echo` на 5й фаловый дескриптор нашего процесса bash. А он, в свою очередь, перенаправляет резултат на вывод экран.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв отображение stdout на pty?  
	Напоминаем: по умолчанию через pipe передаётся только stdout команды слева от `|` на stdin команды справа.
	Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

***Ответ:***
	Да.
	`<command> 2>$1 | <another_command>`

9. Что выведет команда `cat /proc/$$/environ`? Как ещё можно получить аналогичный по содержанию вывод?

***Ответ:***
	`/proc/$$/environ' содержит переменные окружения для процесса с идентификатором $$. 
	Переменные мы можем посмотреть с помощью команды `env`

10. Используя `man`, опишите, что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

***Ответ:***
	`/proc/<PID>/cmdline` это файл, содержащий полную командную строку для процесса <PID>
	`/proc/<PID>/exe` - это символьная ссылка на бинарный файл процесса <PID>

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

***Ответ:***
	`cat /proc/cpuinfo | grep sse`
	`sse4_2`


12. При открытии нового окна терминала и `vagrant ssh` создаётся новая сессия и выделяется pty.  
	Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2.  
	
	Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит и как изменить поведение.

***Ответ:***
	Это происходит потому что по умолчанию, при запуске команды на удаленном хосте с помощью ssh, TTY не выделяется для удаленной сессии. Однако, когда вы запускаете ssh не удаленно, система выделяет TTY, потому что вы, вероятно, будете запускать сеанс оболочки.

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

***Ответ:***
	Определим PID процесса screen с помощью команды:
	`ps aux  | grep screen`
	`reptyr <PID>`

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell, который запущен без `sudo` под вашим пользователем. Для решения этой проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте, что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

***Ответ:***
	Команда `tee` читает из стандартного ввода и записывает в стандартный вывод и один или несколько файлов. Когда вы используете `sudo tee`, команда `tee`запускается с правами суперпользователя и может записывать в файлы, доступные только для суперпользователя. В отличие от `sudo echo`, который запускает команду `echo` с правами суперпользователя, но перенаправление выполняется оболочкой, которая запущена без `sudo` под вашим пользователем. В данном случае, команда `sudo tee` работает, потому что она позволяет записывать в файлы с правами суперпользователя.
